#Подвиг 2. Объявите анонимную (лямбда) функцию с одним параметром для возведения числа в квадрат.
# Присвойте эту функцию переменной get_sq.
# Вызывать функцию не нужно, только задать.

# Решение:
#get_sq = lambda a: a**2

#Подвиг 3. Объявите анонимную (лямбда) функцию с двумя параметрами для деления одного целого числа на другое.
# Если происходит деление на ноль, то функция должна возвращать значение None, иначе - результат деления.
# Присвойте эту функцию переменной get_div. Вызывать функцию не нужно, только задать.

# Решение:
#get_div = lambda a, b: a / b if b != 0 else None

#Подвиг 4. Объявите анонимную (лямбда) функцию для вычисления модуля числа
# (то есть, отрицательные числа нужно делать положительными). Вызовите эту функцию для введенного числа x:
#x = float(input())
#Отобразите результат работы функции на экране.
#Sample Input:
#-5.6
#Sample Output:
#5.6

# Решение:

#x = float(input())
#to_do = lambda a: abs(a)
#print (to_do(x))

#Подвиг 5. Объявите анонимную (лямбда) функцию для определения вхождения в переданную ей строку фрагмента "ra".
# То есть, функция должна возвращать True, если такой фрагмент присутствует в строке и False - в противном случае.
#Вызовите эту функцию для введенной строки s:
#s = input()
#Отобразите результат работы функции на экране.
#Sample Input:
#abrakadabra
#Sample Output:
#True

# Решение:
#s = input()
#findRA = lambda a: True if 'ra' in a else False
#print(findRA(s))

#Подвиг 6. В программе задана функция filter_lst (см. программу ниже), которая отбирает элементы, переданного ей
# итерируемого объекта и возвращает сформированный кортеж значений.
#На вход программы поступает список целых чисел, записанных в одну строчку через пробел. Вызовите функцию filter_lst
# для формирования:
#- кортежа из всех значений входного списка (передается в параметр it);
#- кортежа только из отрицательных чисел;
#- кортежа только из неотрицательных чисел (то есть, включая и 0);
#- кортежа из чисел в диапазоне [3; 5]
#Каждый результат работы функции следует отображать с новой строки командой:
#print(*lst)
#где lst - список на возвращенный функцией filter_lst. Для отбора нужных значений формальному параметру key
# следует передавать соответствующие определения анонимной функции.

# Решение:
#def filter_lst(it, key=None):
 #   if key is None:
  #      return tuple(it)

   # res = ()
    #for x in it:
     #   if key(x):
      #      res += (x,)

    #return res
# здесь продолжайте программу
#a = list(map(int, input().split()))
#- кортеж из всех значений входного списка (передается в параметр it);
#lst = filter_lst(a, key=None)
#print(*lst)
#- кортеж только из отрицательных чисел;
#lst = filter_lst(a, key=lambda x: x < 0)
#print(*lst)
#- кортежа только из неотрицательных чисел (то есть, включая и 0);
#lst = filter_lst(a, key=lambda x: x >= 0)
#print(*lst)
#- кортежа из чисел в диапазоне [3; 5]
#lst = filter_lst(a, key=lambda x: x>=3 and x <=5)
#print(*lst)
