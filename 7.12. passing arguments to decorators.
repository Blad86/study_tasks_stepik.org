# Передача аргументов декораторам

# Подвиг 1. Вводится строка целых чисел через пробел. Напишите функцию, которая преобразовывает эту строку в
# список чисел и возвращает их сумму.
# Определите декоратор для этой функции, который имеет один параметр start - начальное значение суммы.
# Примените декоратор со значением start=5 к функции и вызовите декорированную функцию для введенной строки s:
# s = input()
# Результат отобразите на экране.
# Sample Input:
# 5 6 3 6 -4 6 -1
# Sample Output:
# 26

# Решение:
#def df_decorator(start=int(0)):
 #   def decorator(func):
  #      def wrapper(*args, **kwargs):
   #         res = start + func(*args, **kwargs)

    #        return res

     #   return wrapper
    #return decorator


#@df_decorator(start=5)
#def to_list(s):
 #   s = list(map(int, s.split()))
  #  return sum(s)

#s=input()
#print(to_list(s))

# Подвиг 2. Объявите функцию, которая возвращает переданную ей строку в нижнем регистре (с малыми буквами).
# Определите декоратор для этой функции, который имеет один параметр tag, определяющий строку с названием тега и
# начальным значением "h1". Этот декоратор должен заключать возвращенную функцией строку в тег tag
# и возвращать результат.
# Пример заключения строки "python" в тег h1: <h1>python</h1>
# Примените декоратор со значением tag="div" к функции и вызовите декорированную функцию для введенной строки s:
# s = input()
# Результат отобразите на экране.
# Sample Input:
# Декораторы - это классно!
# Sample Output:
# <div>декораторы - это классно!</div>

# Решение:
#def df_decorator(tag='h1'):
 #   def decorator(func):
  #      def wrapper(*args, **kwargs):
   #         res = f'<{tag}>{func(*args, **kwargs)}</{tag}>'
    #        return res

     #   return wrapper
    #return decorator


#@df_decorator(tag='div')
#def to_lower(s):
 #   return s.lower()

#s = input()
#print(to_lower(s))

# Подвиг 3. Объявите функцию, которая принимает строку на кириллице и преобразовывает ее в латиницу,
# используя следующий словарь для замены русских букв на соответствующее латинское написание:

#t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
 #    'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
  #   'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
   #  'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#Функция должна возвращать преобразованную строку. Замены делать без учета регистра (исходную строку перевести в
# нижний регистр - малые буквы).
#Определите декоратор с параметром chars и начальным значением " !?", который данные символы преобразует в символ "-"
# и, кроме того, все подряд идущие дефисы (например, "--" или "---") приводит к одному дефису.
# Полученный результат должен возвращаться в виде строки.
#Примените декоратор с аргументом chars="?!:;,. " к функции и вызовите декорированную функцию для введенной строки s:
#s = input()
#Результат отобразите на экране.
#Sample Input:
#Декораторы - это круто!
#Sample Output:
#dekoratory-eto-kruto-

# Решение:

#from functools import wraps

#t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
 #    'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
  #   'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
   #  'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}


#def decor(simbol='" !?"'):
 #   def decorator(func):
  #      @wraps(func)
   #     def wrapper(*args, **kwargs):
    #        f = func(*args, **kwargs)
     #       for i in simbol:
      #          if i in f:
       #             return wrapper(f.replace(i, '-'), t)
        #        if '--' in f:
         #           return wrapper(f.replace('--', '-'), t)
          #  return f

        #return wrapper

    #return decorator


#s = input().lower()


#@decor(simbol='"?!:;,. "')
#def translate_(s, t):
 #   x = ''.join([t[x] if t.get(x) else x for x in s])
  #  return x


#print(translate_(s, t))

#Подвиг 4. Объявите функцию с именем get_list и следующим описанием в теле функции:
#'''Функция для формирования списка целых значений'''
#Сама функция должна формировать и возвращать список целых чисел, который поступает на ее вход в виде строки
# из целых чисел, записанных через пробел.
#Определите декоратор, который выполняет суммирование значений из списка этой функции и возвращает результат.
#Внутри декоратора декорируйте переданную функцию get_list с помощью команды @wraps
# (не забудьте сделать импорт: from functools import wraps).
# Такое декорирование необходимо, чтобы исходная функция get_list сохраняла свои локальные свойства: __name__ и __doc__.
#Примените декоратор к функции get_list, но не вызывайте ее.

# Решение:

#from functools import wraps

#def df_decorator(start = int(0)):
 #   def decorator(f):
  #      @wraps(f)
   #     def wrapper(*args, **kwargs):
    #        res = start + sum(f(*args, **kwargs))
     #       return res

      #  return wrapper
    #return decorator


#@df_decorator(start=0)
#def get_list(s):
 #   """Функция для формирования списка целых значений"""
  #  s = list(map(int, s.split()))
   # return s
