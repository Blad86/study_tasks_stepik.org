# Декораторы функций.

#Подвиг 1. Объявите функцию с именем get_sq, которая вычисляет площадь прямоугольника по двум параметрам:
# width и height - ширина и высота прямоугольника. И возвращает результат (сама ничего на экран не выводит).
# То есть, функция имеет сигнатуру:
#def get_sq(width, height): ...
#Определите декоратор func_show для этой функции, который отображает результат на экране в виде строки (без кавычек):
#"Площадь прямоугольника: <значение>"
#Вызывать функцию и декоратор не нужно, только объявить. Применять декоратор к функции также не нужно.
#Sample Input:
#8 11
#Sample Output:
#Площадь прямоугольника: 88

# Решение:

#def func_show(func):                                                                  # объявляем функцию декоратор
    #def wrapper(*args, **kwargs):                                          # функция, которая выполняет блок команд
        #result = func(*args, **kwargs)                                            # запускаем оборачиваемую функцию
        #print(f"Площадь прямоугольника: {result}")                             # выводим результат согласно задания
    #return wrapper                                                   # возвращаем результат блока команд (запускаем)

#@func_show                                                                             # вид упакованного декоратора
#def get_sq(width, height):                                                    # объявляем функцию вычисления площади
    #sq = width*height                                                                            # вычисляем площадь
    #return sq                                                                        # возвращаем вычисление площади


#Подвиг 2. На вход программы поступает строка с названиями пунктов меню, записанные в одну строчку через пробел.
# Необходимо задать функцию с именем get_menu, которая преобразует эту строку в список из слов и возвращает этот список.
# Сигнатура функции, следующая:
#def get_menu(s): ...
#Определите декоратор для этой функции с именем show_menu, который отображает список на экран в формате:
#1. Пункт_1
#2. Пункт_1
#...
#N. Пункт_N
#Примените декоратор show_menu к функции get_menu, используя оператор @. Более ничего в программе делать не нужно.
# Сами функции не вызывать.
#Sample Input:
#Главная Добавить Удалить Выйти
#Sample Output:
#1. Главная
#2. Добавить
#3. Удалить
#4. Выйти

# Решение:
#def show_menu(func):
 #   def wrapper(*args, **kwargs):
  #      for index, word in enumerate(func(*args, **kwargs)):
   #         print(f'{index+1}. {word}')

    #return wrapper


#@show_menu
#def get_menu(s):
 #   s = s.split()
  #  return s

# Подвиг 3. На вход программы поступает строка из целых чисел, записанных через пробел.
# Напишите функцию get_list, которая преобразовывает эту строку в список из целых чисел и возвращает его.
# Определите декоратор для этой функции, который сортирует список чисел по возрастанию. Результат сортировки должен
# возвращаться при вызове декоратора.
# Вызовите декорированную функцию get_list и отобразите полученный отсортированный список lst командой:
# print(*lst)
# Sample Input:
# 8 11 -5 4 3 10
# Sample Output:
# -5 3 4 8 10 11

# Решение:

#def decorator(func):
 #   def wrapper(*args, **kwargs):
  #      res = sorted(func(*args, **kwargs))
   #     return res
    #return wrapper


#@decorator
#def get_list(s):
 #   s = list(map(int, s.split()))
  #  return s

#lst = input()
#lst = (get_list(lst))
#print(*lst)

# Подвиг 4. Вводятся две строки из слов (слова записаны через пробел).
# Объявите функцию, которая преобразовывает эти две строки в два списка слов и возвращает эти списки.
# Определите декоратор для этой функции, который из двух списков формирует словарь, в котором ключами являются слова из
# первого списка, а значениями - соответствующие элементы из второго списка.
# Полученный словарь должен возвращаться при вызове декоратора.
# Примените декоратор к первой функции и вызовите ее для введенных строк. Результат (словарь d) отобразите на экране командой:
#print(*sorted(d.items()))
#Sample Input:
#house river tree car
#дом река дерево машина
#Sample Output:
#('car', 'машина') ('house', 'дом') ('river', 'река') ('tree', 'дерево')

# Решение:
#eng = input().split()
#rus = input().split()


#def to_dict(func):
 #   def wrapper(eng, rus):
  #      d = dict(zip(eng, rus))
   #     return d
    #return wrapper


#@to_dict
#def get_list(a, b):
 #   a = a.split()
  #  b = b.split()
   # return a,b

#d = get_list(eng,rus)
#print(*sorted(d.items()))

#Подвиг 5. Объявите функцию, которая принимает строку на кириллице и преобразовывает ее в латиницу,
# используя следующий словарь для замены русских букв на соответствующее латинское написание:
# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
  #   'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
   #  'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
    # 'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
#Функция должна возвращать преобразованную строку. Замены делать без учета регистра (исходную строку перевести в
# нижний регистр - малые буквы). Все небуквенные символы ": ;.,_" превращать в символ '-' (дефиса).
# Определите декоратор для этой функции, который несколько подряд идущих дефисов, превращает в один дефис.
# Полученная строка должна возвращаться при вызове декоратора. (Сам декоратор на экран ничего выводить не должен).
# Примените декоратор к первой функции и вызовите ее для введенной строки s на кириллице:
# s = input()
# Результат работы декорированной функции отобразите на экране.
# Sample Input:
# Python - это круто!
# Sample Output:
# python-eto-kruto!

# Решение:

#t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
 #    'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
  #   'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
   #  'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}


#def decorator(function):
 #   def wrapper(text):
  #      message = function(text)
   #     while '--' in message:
    #        message = message.replace('--', '-')

     #   return message

    #return wrapper


#@decorator
#def converter(text):
 #   result = []
  #  for char in text:
   #     if char in t:
    #        result.append(t[char])
     #   else:
      #      result.append(char)

    #return ''.join(result)


#s = input().lower()
#print(converter(s).replace(' ', '-').replace('---', '-'))
